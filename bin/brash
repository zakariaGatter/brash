#!/usr/bin/env bash

#--------#
# DEBUG  #
#--------#{{{
#set -e -x -v
#}}}

#-------------#
# SCRIPT NAME #
#-------------#{{{
name=${0##*/}
#}}}

#----------------#
# TARSH LOCATION #
#----------------#{{{
# get Trash variable from Devices
while read -ra part ; do
	type="${part[1]}"
	uuid="${part[2]}"
	mount="${part[3]}"

	[ "$type" = "part" ] && [ -z "$(awk '/'"$uuid"'/' /etc/fstab)" ] && [ "$mount" ] && {
		case "$PWD" in
			${mount}* ) TRASH="$mount/.Trash" ;;
		esac
	}
done < <(lsblk -ln -o path,type,uuid,mountpoint)
#}}}

#---------------#
# TRASH FOLDERS #
#---------------#{{{
TRASH=${TRASH:=$HOME/.local/share/Trash}
TRASH_FILES="$TRASH/files"
TRASH_INFO="$TRASH/info"
#}}}

#------------------#
# MAKE TRASH FILES #
#------------------#{{{
[ -d "$TRASH_FILES" ]  || mkdir -p "$TRASH_FILES"
[ -d "$TRASH_INFO" ]   || mkdir -p "$TRASH_INFO"
#}}}

#-------------#
# MSG DIALOG  #
#-------------#{{{
msg(){ printf "%s: %b\n" "${name^}" "$@" >&2 ;}
#}}}

#-----------#
# ERROR MSG #
#-----------#{{{
die(){ printf "%s: %b\n" "${name^}" "$@" >&2 ; exit 2 ;}
#}}}

#-------------#
# REMOVE FILE #
#-------------#{{{
remove(){
local i I

[ "${_list_[*]}" ] || die "missing file operand \ntry '$name -h' for more information."

for i in "${_list_[@]}" ; do
	local _file_=${i}
	local _path_=$(realpath -s -- "$_file_" 2> /dev/null)
	local _file_name_=${_path_##*/}
	local _file_path_=${_path_%/*}
    local size count

    # check for file existing
    [ -e "$_file_" ] || die "$_file_: No such file or Directory."

    # check for file permission
    [ -w "$_file_" ] || die "Can't Delete '$_file_' Permission denied"

    # get file size
    read -ra size < <(du -hs "$_file_" 2> /dev/null)

    # get count if there is any double
    read -r count < <(ls -1v $TRASH_FILES/${_file_name_}* 2> /dev/null | awk -F '[()]' '{line=$2}END{print line}')

    [ "$count" ] && {
        ((count++))
        _file_name_="${_file_name_}(${count})"
    } || {
        [ -e "$TRASH_FILES/$_file_name_" ] && _file_name_="${_file_name_}(1)"
    }

    ( mv -f -- "$_file_" "$TRASH_FILES/$_file_name_" 2> /dev/null ) && {
        printf "[Trash Info]\n"                    > "$TRASH_INFO/$_file_name_.trashinfo"
        printf "DeletionDate=%(%F)TT%(%T)T\n"     >> "$TRASH_INFO/$_file_name_.trashinfo"
        printf "PATH=%s\n" "$_file_path_/$_file_" >> "$TRASH_INFO/$_file_name_.trashinfo"
    } || die "Delele [ERROR] '$_file_'"

    [ "$VERBOSE" ] && msg "Delete [$size] '$_file_'"
    [ "$WAIT" ] && [ $WAIT -eq $WAIT ] 2> /dev/null && sleep $WAIT || die "'$WAIT' invalid number giving"
done
}
#}}}

#------------#
# LIST FILES #
#------------#{{{
list(){
(ls $TRASH_INFO/* &> /dev/null) || die "Trash [EMPTY]"

for i in $TRASH_INFO/* ; do
	local _file_=$(awk -F = '/^PATH=/{print $2}' "$i")
	local _date_=$(awk -F = '/^DeletionDate=/{sub("T"," ",$2); print $2}' "$i")

    msg "List [$_date_] '$_file_'"
done
}
#}}}

#-------------#
# CLEAN TRASH #
#-------------#{{{
clean(){
(ls $TRASH_INFO/* &> /dev/null) || die "Trash [EMPTY]"

msg "Clean [INFO]"
rm -rf -- $TRASH_INFO/*

msg "Clean [FILE]"
rm -rf -- $TRASH_FILES/*

}
#}}}

#------------------------------#
# LIST FILES FOR BRASH RETORE  #
#------------------------------#{{{
_list_files_(){
for i in $TRASH_INFO/* ; do
	local _file_=$(awk -F = '/^PATH=/{print $2}' "$i")
	local _date_=$(awk -F = '/^DeletionDate=/{sub("T"," ",$2); print $2}' "$i")
	i=${i##*/}
    printf "'%s' '%s' OFF " "${i%.*}" "$_file_ $_date_"
done
}
#}}}

#--------------#
# RESTORE FILE #
#--------------#{{{
restore(){
(ls $TRASH_INFO/* &> /dev/null) || die "Trash [EMPTY]"

read -r LINES COLUMNS < <(stty size)

_RF_="${_list_[@]}"

[ "$_RF_" ] || {
	DIALOG_TTY=1
	_RF_=$(eval "dialog --stdout --title 'Brash Restore' --checklist 'Pick Files (Accept Multiple) :' $LINES $COLUMNS $(($LINES - 8)) $(_list_files_)")
}

[ "$_RF_" ] && {
	for i in ${_RF_[@]}; do
		local _file_=$(awk -F = '/^PATH=/{print $2}' "$TRASH_INFO/$i.trashinfo")

        [ -w "$TRASH_INFO/$i" ] || die "Can't Restore '$_file_' Permission denied"

        [ -f "$_file_" ] && _file_="${_file_}(1)"

		mv -f -- "$TRASH_FILES/$i" "$_file_" 2> /dev/null
        rm -f -- "$TRASH_INFO/$i.trashinfo"  2> /dev/null

		[ "$VERBOSE" ] && msg "Restore '$_file_'"
	done
}
}
#}}}

#-------------#
# TRASH SIZE  #
#-------------#{{{
size(){
    local size count

    read -r size < <(du -hs "$TRASH"/* | awk '/total$/{print $1}')
    read -r count < <(ls -1 "$TRASH"/* | wc -l)

    msg "Size [$size], Files [$count]"
}
#}}}

#-------------#
# HELP DIALOG #
#-------------#{{{
help(){
while read; do
    printf "%s\n" "$REPLY"
done <<- HELP
${name^^} Cli Trash Manager in bure Bash

$name [OPTS] [FILES]

OPTS :
  -d <FILES> : Delete File and Directories
  -c         : Clean Trash Files and Infos
  -l         : List Trash Files
  -r <FILES> : Restore Files from trash
  -s         : Trash Size
  -w <NUM>   : Wait before delete the next file in Seconds
  -v         : Explain what is being done
  -h         : Display this help text and exit
HELP

exit 0
}
#}}}

#---------------#
# MAIN FUNCTION #
#---------------#{{{
main(){
while getopts ":dlcrsvw:h" OPT ; do
    case "$OPT" in
        d )
            REMOVE=true
            ;;
        l )
            LIST=true
            ;;
        c )
            CLEAN=true
            ;;
        r )
            RESTORE=true
            ;;
        s )
            SIZE=true
            ;;
        h )
            HELP=true
            ;;
        v )
            VERBOSE=true
            ;;
        w )
            WAIT="${OPTARG}"
            ;;
        * )
            die "invalid option -- '$OPTARG' \nTry '$name -h' for more information"
            ;;
        : )
			die "option requires an argument -- '$OPTARG' \nTry '$name -h' for more information."
            ;;
    esac

done

shift $(($OPTIND - 1))

# get all files even with spaces
while read ; do
    _list_+=( "$REPLY" )
done < <(printf "%s\n" "$@")
}
#}}}

#-------------------#
# RUN MAIN FUNCTION #
#-------------------#{{{
main "$@"
#}}}

#---------------#
# DETECT ERRORS #
#---------------#{{{
[ "$HELP" ]    && help      || true
[ "$REMOVE" ]  && remove    || true
[ "$LIST" ]    && list      || true
[ "$CLEAN" ]   && clean     || true
[ "$RESTORE" ] && restore   || true
[ "$SIZE" ]    && size      || true
#}}}

